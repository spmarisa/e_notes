we will learn how to build a complete Elixir application, with its own supervision tree, configuration, tests and more.

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

#CREATE shopping
#OK

#PUT shopping milk 1
#OK

#PUT shopping eggs 3
#OK

#GET shopping milk
#1
#OK

#DELETE shopping eggs
#OK

#############################################################################################################################
to build a key-value application, we need 3 main tools

OTP - open telecom platform -  set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

MIX - a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit - is a test-unit based framework that ships with Elixir;



#############################################################################################################################

OUR FIRST PROJECT

#create our first project by invoking mix new from the command line. Weâ€™ll pass the project name as argument (kv, in this case), and tell Mix that our main module should be the all-uppercase KV, instead of the default, which would have been Kv:

$ mix new kv --module KV



#############################################################################################################################
PROJECT COMPILATION

A file named mix.exs was generated inside our new project folder (kv) and its main responsibility is to configure our project.

Our mix.exs defines two public functions: project, which returns project configuration like the project name and version, and application, which is used to generate an application file.

There is also a private function named deps, which is invoked from the project function, that defines our project dependencies. Defining deps as a separate function is not required, but it helps keep the project configuration tidy.


Mix also generates a file at lib/kv.ex with a simple module definition:


This structure is enough to compile our project:
$ cd kv
$ mix compile
