# But what if you have a huge chunk of quoted code and want to understand it? In this case, you can use Macro.to_string/2.
Macro.to_string(quote(do: foo.bar(1, 2, 3)))

# when you want to look at the code generated by macros you can combine them with Macro.expand/2 and Macro.expand_once/2, these functions expand macros into their given quoted code. The first may expand it several times, while the former - only once. For example, let’s modify unless example from the previous section:
defmodule OurMacro do
  defmacro unless(expr, do: block) do
    quote do
      if !unquote(expr), do: unquote(block)
    end
  end
end

require OurMacro
quoted = quote do
  OurMacro.unless true, do: "Hi"
end


quoted |> Macro.expand_once(__ENV__) |> Macro.to_string |> IO.puts
# if(!true) do
#   "Hi"
# end

quoted |> Macro.expand(__ENV__) |> Macro.to_string |> IO.puts
# case(!true) do
#   x when x in [false, nil] ->
#     nil
#   _ ->
#     "Hi"
# end

# You may recall that we’ve mentioned if is a macro in Elixir, here we see it expanded into the underlying case statement.

###############################################################################################################################

# Private Macros
# Though not as common, Elixir does support private macros. A private macro is defined with defmacrop and can only be called from the module in which it was defined. Private macros must be defined before the code that invokes them.


##############################################################################################################################
# Macro Hygiene

# How macros interact with the caller’s context when expanded is known as macro hygiene. By default macros in Elixir are hygienic and will not conflict with our context:

defmodule Example do
  defmacro hygienic do
    quote do: val = -1
  end
end

iex> require Example
nil
iex> val = 42
42
iex> Example.hygienic
-1
iex> val
42

What if we wanted to manipulate the value of val? To mark a variable as being unhygienic we can use var!/2. Let’s update our example to include another macro utilizing var!/2:

defmodule Example do
  defmacro hygienic do
    quote do: val = -1
  end

  defmacro unhygienic do
    quote do: var!(val) = -1
  end
end

Let’s compare how they interact with our context:

iex> require Example
nil
iex> val = 42
42
iex> Example.hygienic
-1
iex> val
42
iex> Example.unhygienic
-1
iex> val
-1

By including var!/2 in our macro we manipulated the value of val without passing it into our macro. The use of non-hygienic macros should be kept to a minimum. By including var!/2 we increase the risk of a variable resolution conflict.
Binding

We already covered the usefulness of unquote/1, but there’s another way to inject values into our code: binding. With variable binding we are able to include multiple variables in our macro and ensure they’re only unquoted once, avoiding accidental revaluations. To use bound variables we need to pass a keyword list to the bind_quoted option in quote/2.

To see the benefit of bind_quote and to demonstrate the revaluation issue let’s use an example. We can start by creating a macro that simply outputs the expression twice:

defmodule Example do
  defmacro double_puts(expr) do
    quote do
      IO.puts unquote(expr)
      IO.puts unquote(expr)
    end
  end
end

We’ll try out our new macro by passing it the current system time. We should expect to see it output twice:

iex> Example.double_puts(:os.system_time)
1450475941851668000
1450475941851733000

The times are different! What happened? Using unquote/1 on the same expression multiple times results in revaluation and that can have unintended consequences. Let’s update the example to use bind_quoted and see what we get:

defmodule Example do
  defmacro double_puts(expr) do
    quote bind_quoted: [expr: expr] do
      IO.puts expr
      IO.puts expr
    end
  end
end

iex> require Example
nil
iex> Example.double_puts(:os.system_time)
1450476083466500000
1450476083466500000

With bind_quoted we get our expected outcome: the same time printed twice.

Now that we’ve covered quote/2, unquote/1, and defmacro/2 we have all the tools necessary to extend Elixir to suit our needs.
